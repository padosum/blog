---
title   : JavaScript 실행 컨텍스트
date    : 2021-09-16 22:05:36 +0900
updated : 2021-09-16 22:05:37 +0900
tags    : ["JavaScript"]
---
 실행 컨텍스트(execution context)는 짧게 '컨텍스트'라 부른다. 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다. 변수나 함수의 실행 컨텍스트는 변수나 함수가 어떻게 행동하는지를 규정한다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 [[JavaScript-Block-Level-Scope|선언된 변수를 끌어올리고]], 외부 환경 정보를 구성하고, `this` 값을 설정하는 등 동작을 수행하게 된다. 그래서 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생하기도 한다.

지금부터 실행 컨텍스트의 동작을 통해 자바스크립트에서 소스코드가 어떻게 실행되는지 알아보자.  

## 소스코드의 평가와 실행 
모든 소스코드는 실행 전에 평가 과정을 거치면서 실행을 위한 준비를 한다. [[JavaScript-Engine|자바스크립트 엔진]]은 "소스코드 평가"와 "소스코드 실행"의 두 과정을 처리한다.  
평가 과정에서는 실행 컨텍스트를 생성해 변수, 함수 등의 선언문만 먼저 실행해서 생성된 변수와 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.  

평가 과정이 끝나면 비로소 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다. (런타임이 시작된다.) 이때 소스코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. 그리고 변수 값의 변경 등 소스코드의 실행 결과가 다시 실행 컨텍스트가 관리하는 스코프에 등록이된다.  
```javascript
var x;
x = 1;
```
위 코드는 아래 그림과 같이 실행 컨텍스트를 통해 처리된다. 우선 자바스크립트 엔진이 소스코드 평가 과정에서 변수 선언문 `var x;`를 먼저 실행하고 이때 생성된 식별자 `x`가 실행 컨텍스트가 관리하는 스코프에 등록되어 `undefined`로 초기화된다. 평가 과정이 끝나면 실행 과정이 시작된다. 이때 실행 컨텍스트가 관리하는 스코프에 `x`가 등록되어 있는지 확인을 한다. 등록되어 있다면 선언된 변수이므로 값을 할당하고 할당 결과를 다시 실행 컨텍스트에 등록해 관리한다.  
![[source code execution.png]]

 ## 실행 컨텍스트 스택 (콜 스택) 
 자바스크립트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성한다. 생성된 실행 컨텍스트는 [[스택]]으로 관리된다. 이를 **실행 컨텍스트 스택**이라 부르는데, **콜 스택**이라고 부르기도 한다. 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 **전체 코드의 환경과 순서를 보장**한다.  
 여기서 말하는 컨텍스트를 구성하는 '동일한 환경'에는 다음과 같은 것들이 있다.
 - 전역 코드
	- 전역에 존재하는 코드
- 함수 코드
	- 함수 내부에 존재하는 코드
- eval 코드
	- `eval` 함수에 인수로 전달되어 실행되는 코드 
- 모듈 코드
	- 모듈 내부에 존재하는 코드

---
다음 코드를 살펴보자.  
 ```javascript
const x = 1;
const y = 2;

function sum(a, b) {
  const x = 100; 
  const y = 200;
  console.log(x + y + a + b);
}

sum(x, y); // 303 

console.log(x + y); // 3
 ```

![[execution-context-stack1.png]]

1. 앞에서 살펴본 것과 같이 자바스크립트 엔진은 우선 전역 코드를 평가하고 실행을 위한 준비를 한다. 선언문을 먼저 실행해 그 결과가 실행 컨텍스트가 관리하는 전역 스코프에 등록한다.  
2. 전역 코드 평가가 끝이나면 전역 코드가 순차적으로 실행된다. 이때 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면, 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경해 함수 내부로 진입하게 된다.
3. 함수 내부로 진입하면 함수 내부의 문들을 실행하기 전에 함수 코드 평가 과정을 거친다. 이때 매개변수와 지역 변수 선언문이 먼저 실행되고, 그 결과가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. 함수 내부에서는 `arguments` 객체가 생성되어 실행 컨텍스트가 관리하는 지역 스코프에 등록되고, [[JavaScript-this|this]] 바인딩도 결정된다.
4. 함수 코드 평가 과정이 끝이나면 함수 코드가 순차적으로 실행된다. 값이 할당되고 여기서는 `console.log` 메서드를 호출하기 위해 식별자인 `console`을 [[JavaScript-Scope-Chain|스코프 체인]]을 통해 검색한다. `console.log` 메서드가 실행되고 나면, 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.  


---

- 각 실행 컨텍스트에는 변수 객체(variable object)가 연결되어 있으며 해당 컨텍스트에서 정의된 모든 변수와 함수는 이 객체에 존재한다. 
	- 이 객체를 코드에서 접근할 수는 없지만 이면에서 데이터를 다룰 때 이 객체를 이용 
- 가장 바깥쪽에 존재하는 실행 컨텍스트는 전역 컨텍스트 
	- ES를 구현한 환경에 따라 이 컨텍스트를 부르는 이름이 다르다. 
	- 웹 브라우저에서는 이 컨텍스트를 window라 부르므로 전역 변수와 함수는 모두 window 객체의 프로퍼티 및 메서드로 생성된다. 
- 실행 컨텍스트는 포함된 코드가 모두 실행될 때 파괴되는데, 이 때 해당 컨텍스트 내부에서 정의된 변수와 함수도 함께 파괴된다. 
- 전역 컨텍스트는 애플리케이션이 종료될 때, 웹 페이지에서 나가거나 브라우저를 닫을 때까지 유지 
- 함수를 호출하면 독자적인 실행 컨텍스트가 생성
	- 코드 실행이 함수로 들어갈 때마다 함수의 컨텍스트가 컨텍스트 스택에 쌓임 
	- 함수 실행이 끝나면 해당 컨텍스트를 스택에서 꺼내고 컨트롤을 이전 컨텍스트에 반환 
	- ES 프로그램은 모두 이런식으로 실행 된다. 
- 컨텍스트에서 코드를 실행하면 변수 객체에 '스코프 체인(scope chain)이 만들어짐 
	- 스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것 
	- 스코프 체인의 앞쪽은 항상 코드가 실행되는 컨텍스트의 변수 객체 
	- 컨텍스트가 함수라면 '활성화 객체(activation object)를 변수 객체로 사용 
	- 활성화 객체는 항상 arguments 변수 단 하나로 시작 
	- 변수 객체의 다음 순서는 해당 컨텍스트를 포함하는 컨텍스트(부모 컨텍스트)
	- 그 다음은 다시 부모의 부모 컨텍스트 
	- 이런 식으로 계속 진행해 전역 컨텍스트에 도달할 때까지 진행 
	- 전역 컨텍스트의 변수 객체는 항상 스코프 체인의 마지막에 존재
- 식별자를 찾을 때는 스코프 체인의 순서를 따라가면서 해당 식별자 이름을 검색한다. (식별자를 찾을 수 없다면 일반적으로 에러 발생) 

```javascript
var color = "blue";
function changeColor() {
    if (color === "blue") {
		color = 'red';
    } else {
        color = 'blue';
    }
}

changeColor();
```

	- changeColor()의 스코프 체인에는 객체가 두개 
		- 하나는 함수 자체의 변수 객체(arguments 객체는 여기에 정의)
		- 하나는 전역 컨텍스트의 변수 객체 
	- 변수 color는 함수의 스코프 체인에서 찾을 수 있으므로 접근 가능 
	- 로컬 컨텍스트에서는 지역 변수와 전역 변수를 모두 쓸 수 있따. 
```javascript
var color = "blue";

function changeColor() {
    var anotherColor = 'red';

	  function swapColor() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;

        // color, anotehrColor, tempColor 모두 접근 가능 
    } 

    // color, anotherColor 접근 가능, tempColor 불가능
    swapColors();
}

//color만 접근 가능
changeColor();
```

- 실행 컨텍스트가 총 세 개 있다.  
	- 전역 컨텍스트, changeColor()의 로컬 컨텍스트, swapColor()의 로컬 컨텍스트 
- 전역 컨텍스트에는 color 변수와 changeColor() 함수가 포함 
- changeColor()의 로컬 컨텍스트에는 anotherColor 변수와 swapColors() 함수만 있지만 전역 컨텍스트의 color 변수에도 접근 가능하다. 
- swapColors()의 로컬 컨텍스트에 있는 tempColor 변수는 오직 이 컨텍스트에서만 접근 가능 
- swapColors()에서는 부모인 다른 두 컨텍스트의 변수에 자유로이 접근 가능 
- 내부 컨텍스트는 스코프 체인을 통해 외부 컨텍스트 전체에 접근 가능하지만 외부 컨텍스트는 내부 컨텍스트에 대해 전혀 알 수 없습니다. 
- 컨텍스트 사이의 연결은 선형이며 순서가 중요 
- 각 컨텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수나 함수를 검색할 수 있지만 스코프 체인을 따라 내려가며 검색할 수는 없다. 
- swapColors()의 로컬 컨텍스트 스코프 체인에는 객체가 세 개 있음
	- 하나는 swapColors()의 변수 객체 
	- 다른 하나는 changeColor()의 변수 객체
	- 마지막은 전역 변수 객체 
- swapColors()의 로컬 컨텍스트는 자신의 변수 객체에서 변수나 함수 이름을 검색한 다음 찾지 못하면 스코프 체인에 따라 한 단계 씩 올라감 



